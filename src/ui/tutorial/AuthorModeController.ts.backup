import * as path from 'path';
import * as vscode from 'vscode';
import {
  WebviewToExtensionAuthorMessage,
  AuthorManifestData,
  ManifestStep,
} from '@gitorial/shared-types';
import { AuthorManifest } from '@domain/models/AuthorManifest';
import { TutorialPublishService } from '@domain/services/TutorialPublishService';
import { IGitOperations } from '@domain/ports/IGitOperations';
import { IFileSystem } from '@domain/ports/IFileSystem';
import { IUserInteraction } from '@domain/ports/IUserInteraction';
import { SystemController } from '@ui/system/SystemController';
import { ok, err, Result } from 'neverthrow';

export interface IWebviewAuthorMessageHandler {
  handleWebviewMessage(message: WebviewToExtensionAuthorMessage): Promise<void>;
}

export class AuthorModeController implements IWebviewAuthorMessageHandler {
  private publishService: TutorialPublishService;
  private currentManifest: AuthorManifest | null = null;

  constructor(
    private gitOperations: IGitOperations,
    private fileSystem: IFileSystem,
    private userInteraction: IUserInteraction,
    private systemController: SystemController,
  ) {
    this.publishService = new TutorialPublishService(gitOperations);
  }

  public async handleWebviewMessage(message: WebviewToExtensionAuthorMessage): Promise<void> {
    console.log('AuthorModeController: Received webview message', message);

    try {
      switch (message.type) {
        case 'loadManifest':
          await this.handleLoadManifest(message.payload.repositoryPath);
          break;

        case 'saveManifest':
          await this.handleSaveManifest(message.payload.manifest);
          break;

        case 'addStep':
          await this.handleAddStep(message.payload.step, message.payload.index);
          break;

        case 'removeStep':
          await this.handleRemoveStep(message.payload.index);
          break;

        case 'updateStep':
          await this.handleUpdateStep(message.payload.index, message.payload.step);
          break;

        case 'reorderStep':
          await this.handleReorderStep(message.payload.fromIndex, message.payload.toIndex);
          break;

        case 'publishTutorial':
          await this.handlePublishTutorial(message.payload.manifest, message.payload.forceOverwrite);
          break;

        case 'previewTutorial':
          await this.handlePreviewTutorial(message.payload.manifest);
          break;

        case 'validateCommit':
          await this.handleValidateCommit(message.payload.commitHash);
          break;

        case 'exitAuthorMode':
          await this.handleExitAuthorMode();
          break;

        default:
          console.warn('AuthorModeController: Unknown message type:', (message as any).type);
      }
    } catch (error) {
      console.error('AuthorModeController: Error handling message:', error);
      this.systemController.reportError(
        error instanceof Error ? error : new Error(String(error)),
        'Author Mode',
        true
      );
    }
  }

  private async handleLoadManifest(repositoryPath: string): Promise<void> {
    const manifestPath = path.join(repositoryPath, '.gitorial', 'manifest.json');
    
    try {
      const manifestExists = await this.fileSystem.fileExists(manifestPath);
      
      if (!manifestExists) {
        // No manifest exists, send empty state
        await this.systemController.sendAuthorManifest({
          authoringBranch: await this.gitOperations.getCurrentBranch(),
          publishBranch: 'gitorial',
          steps: [],
        }, false);
        return;
      }

      const manifestContent = await this.fileSystem.readFile(manifestPath);
      const manifestData = JSON.parse(manifestContent) as AuthorManifestData;
      
      const createResult = AuthorManifest.create(manifestData);
      if (createResult.isErr()) {
        throw new Error(`Invalid manifest: ${createResult.error}`);
      }

      this.currentManifest = createResult.value;
      await this.systemController.sendAuthorManifest(manifestData, true);
      
      // Send validation warnings if any
      const warnings = this.validateManifest(this.currentManifest);
      if (warnings.length > 0) {
        await this.systemController.sendValidationWarnings(warnings);
      }

    } catch (error) {
      throw new Error(`Failed to load manifest: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private async handleSaveManifest(manifestData: AuthorManifestData): Promise<void> {
    const workspaceFolder = this.getActiveWorkspaceFolder();
    if (!workspaceFolder) {
      throw new Error('No workspace folder available');
    }

    const createResult = AuthorManifest.create(manifestData);
    if (createResult.isErr()) {
      throw new Error(`Invalid manifest data: ${createResult.error}`);
    }

    this.currentManifest = createResult.value;
    
    const manifestPath = path.join(workspaceFolder.fsPath, '.gitorial', 'manifest.json');
    const gitorialDir = path.dirname(manifestPath);
    
    // Ensure .gitorial directory exists
    if (!await this.fileSystem.directoryExists(gitorialDir)) {
      await this.fileSystem.createDirectory(gitorialDir);
    }

    const manifestContent = JSON.stringify(manifestData, null, 2);
    await this.fileSystem.writeFile(manifestPath, manifestContent);
  }

  private async handleAddStep(step: ManifestStep, index?: number): Promise<void> {
    if (!this.currentManifest) {
      throw new Error('No manifest loaded');
    }

    const addResult = index !== undefined 
      ? this.currentManifest.insertStep(index, step)
      : this.currentManifest.addStep(step);

    if (addResult.isErr()) {
      throw new Error(`Failed to add step: ${addResult.error}`);
    }

    await this.saveCurrentManifest();
    await this.sendUpdatedManifest();
  }

  private async handleRemoveStep(index: number): Promise<void> {
    if (!this.currentManifest) {
      throw new Error('No manifest loaded');
    }

    const removeResult = this.currentManifest.removeStep(index);
    if (removeResult.isErr()) {
      throw new Error(`Failed to remove step: ${removeResult.error}`);
    }

    await this.saveCurrentManifest();
    await this.sendUpdatedManifest();
  }

  private async handleUpdateStep(index: number, step: ManifestStep): Promise<void> {
    if (!this.currentManifest) {
      throw new Error('No manifest loaded');
    }

    const updateResult = this.currentManifest.updateStep(index, step);
    if (updateResult.isErr()) {
      throw new Error(`Failed to update step: ${updateResult.error}`);
    }

    await this.saveCurrentManifest();
    await this.sendUpdatedManifest();
  }

  private async handleReorderStep(fromIndex: number, toIndex: number): Promise<void> {
    if (!this.currentManifest) {
      throw new Error('No manifest loaded');
    }

    const reorderResult = this.currentManifest.reorderStep(fromIndex, toIndex);
    if (reorderResult.isErr()) {
      throw new Error(`Failed to reorder step: ${reorderResult.error}`);
    }

    await this.saveCurrentManifest();
    await this.sendUpdatedManifest();
  }

  private async handlePublishTutorial(manifestData: AuthorManifestData, forceOverwrite = false): Promise<void> {
    const createResult = AuthorManifest.create(manifestData);
    if (createResult.isErr()) {
      throw new Error(`Invalid manifest: ${createResult.error}`);
    }

    const manifest = createResult.value;
    
    const publishResult = forceOverwrite 
      ? await this.publishService.publishTutorialForced(manifest)
      : await this.publishService.publishTutorial(manifest);

    if (publishResult.isErr()) {
      await this.systemController.sendPublishResult(false, publishResult.error);
      return;
    }

    const result = publishResult.value;
    await this.systemController.sendPublishResult(
      true,
      undefined,
      result.publishedCommits
    );
  }

  private async handlePreviewTutorial(manifestData: AuthorManifestData): Promise<void> {
    // For now, preview just validates the manifest and sends warnings
    const createResult = AuthorManifest.create(manifestData);
    if (createResult.isErr()) {
      throw new Error(`Invalid manifest: ${createResult.error}`);
    }

    const manifest = createResult.value;
    const warnings = this.validateManifest(manifest);
    await this.systemController.sendValidationWarnings(warnings);
  }

  private async handleValidateCommit(commitHash: string): Promise<void> {
    try {
      const commitInfo = await this.gitOperations.getCommitInfo(commitHash);
      
      // Send commit info back to webview
      // For now, we'll just validate that the commit exists
      // In a full implementation, we'd send the commit info back
      console.log('Commit validation result:', commitInfo ? 'valid' : 'invalid');
      
    } catch (error) {
      console.warn('Commit validation failed:', error);
    }
  }

  private async handleExitAuthorMode(): Promise<void> {
    this.currentManifest = null;
    await this.systemController.setAuthorMode(false);
  }

  // Private helper methods

  private async saveCurrentManifest(): Promise<void> {
    if (!this.currentManifest) {
      throw new Error('No manifest to save');
    }

    const workspaceFolder = this.getActiveWorkspaceFolder();
    if (!workspaceFolder) {
      throw new Error('No workspace folder available');
    }

    const manifestPath = path.join(workspaceFolder.fsPath, '.gitorial', 'manifest.json');
    const manifestContent = JSON.stringify(this.currentManifest.toJSON(), null, 2);
    await this.fileSystem.writeFile(manifestPath, manifestContent);
  }

  private async sendUpdatedManifest(): Promise<void> {
    if (!this.currentManifest) {
      return;
    }

    await this.systemController.sendAuthorManifest(this.currentManifest.toJSON(), true);
    
    // Send validation warnings
    const warnings = this.validateManifest(this.currentManifest);
    await this.systemController.sendValidationWarnings(warnings);
  }

  private validateManifest(manifest: AuthorManifest): string[] {
    const warnings: string[] = [];
    const steps = manifest.steps;

    // Check for template-solution pairing
    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      if (step.type === 'template') {
        const nextStep = steps[i + 1];
        if (!nextStep || nextStep.type !== 'solution') {
          warnings.push(`Template step "${step.title}" should be followed by a solution step`);
        }
      }
    }

    // Check for empty manifest
    if (steps.length === 0) {
      warnings.push('Tutorial has no steps. Add at least one step to publish.');
    }

    return warnings;
  }

  private getActiveWorkspaceFolder(): vscode.WorkspaceFolder | undefined {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
      return undefined;
    }
    return workspaceFolders[0];
  }
}