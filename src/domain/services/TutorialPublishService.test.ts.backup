import { expect } from 'chai';
import * as sinon from 'sinon';
import { ok, err } from 'neverthrow';
import { TutorialPublishService, TutorialPublishError } from './TutorialPublishService';
import { AuthorManifest, ManifestStep } from '../models/AuthorManifest';
import { IGitOperations } from '../ports/IGitOperations';

describe('TutorialPublishService', () => {
  let gitOperationsMock: sinon.SinonStubbedInstance<IGitOperations>;
  let publishService: TutorialPublishService;

  const createTestManifest = (): AuthorManifest => {
    return new AuthorManifest({
      authoringBranch: 'master',
      publishBranch: 'gitorial',
      steps: [
        {
          commit: 'abc123def456',
          type: 'section',
          title: 'Setup Environment',
        },
        {
          commit: 'def456ghi789',
          type: 'template', 
          title: 'Build the pallet',
        },
        {
          commit: 'ghi789jkl012',
          type: 'solution',
          title: 'Build the pallet',
        },
      ],
    });
  };

  beforeEach(() => {
    gitOperationsMock = {
      getCurrentBranch: sinon.stub(),
      checkoutBranch: sinon.stub(), 
      createBranch: sinon.stub(),
      branchExists: sinon.stub(),
      getCommitInfo: sinon.stub(),
      cherryPick: sinon.stub(),
      createCommit: sinon.stub(),
      getCommitMessage: sinon.stub(),
      deleteBranch: sinon.stub(),
      getRepoUrl: sinon.stub(),
      clone: sinon.stub(),
      checkout: sinon.stub(),
      checkoutAndClean: sinon.stub(),
      getRepoName: sinon.stub(),
      getFileContent: sinon.stub(),
      getCurrentCommitHash: sinon.stub(),
      getCommits: sinon.stub(),
      isGitRepository: sinon.stub(),
      getRepoInfo: sinon.stub(),
      listRemote: sinon.stub(),
      cleanWorkingDirectory: sinon.stub(),
      ensureGitorialBranch: sinon.stub(),
      getChangesInCommit: sinon.stub(),
    } as sinon.SinonStubbedInstance<IGitOperations>;
    
    publishService = new TutorialPublishService(gitOperationsMock);
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('publishTutorial', () => {
    it('should successfully publish tutorial when gitorial branch does not exist', async () => {
      const manifest = createTestManifest();
      
      // Setup mocks for successful publish
      gitOperationsMock.getCurrentBranch.resolves('master');
      gitOperationsMock.branchExists.resolves(false);
      gitOperationsMock.createBranch.resolves();
      gitOperationsMock.getCommitInfo.resolves({
        hash: 'abc123def456',
        message: 'Original commit message',
        author: 'Test Author',
        date: new Date(),
      });
      gitOperationsMock.cherryPick.resolves();
      gitOperationsMock.createCommit.resolves('new-commit-hash');

      const result = await publishService.publishTutorial(manifest);

      expect(result.isOk()).to.be.true;
      if (result.isOk()) {
        expect(result.value.publishedCommits).to.have.lengthOf(3);
        expect(result.value.branch).to.equal('gitorial');
      }

      // Verify git operations were called correctly
      expect(gitOperationsMock.createBranch.calledWith('gitorial', 'master')).to.be.true;
      expect(gitOperationsMock.checkoutBranch.calledWith('gitorial')).to.be.true;
      expect(gitOperationsMock.cherryPick.callCount).to.equal(3);
    });

    it('should ask for confirmation when gitorial branch already exists', async () => {
      const manifest = createTestManifest();
      
      gitOperationsMock.getCurrentBranch.resolves('master');
      gitOperationsMock.branchExists.resolves(true);

      const result = await publishService.publishTutorial(manifest);

      expect(result.isErr()).to.be.true;
      if (result.isErr()) {
        expect(result.error).to.equal('BRANCH_EXISTS_CONFIRMATION_NEEDED');
      }
    });

    it('should force publish when confirmation is provided', async () => {
      const manifest = createTestManifest();
      
      gitOperationsMock.getCurrentBranch.resolves('master');
      gitOperationsMock.branchExists.resolves(true);
      gitOperationsMock.deleteBranch.resolves();
      gitOperationsMock.createBranch.resolves();
      gitOperationsMock.checkoutBranch.resolves();
      gitOperationsMock.getCommitInfo.resolves({
        hash: 'abc123def456',
        message: 'Original commit message',
        author: 'Test Author',
        date: new Date(),
      });
      gitOperationsMock.cherryPick.resolves();
      gitOperationsMock.createCommit.resolves('new-commit-hash');

      const result = await publishService.publishTutorial(manifest, true);

      expect(result.isOk()).to.be.true;
      expect(gitOperationsMock.deleteBranch.calledWith('gitorial')).to.be.true;
    });

    it('should handle git operation failures', async () => {
      const manifest = createTestManifest();
      
      gitOperationsMock.getCurrentBranch.resolves('master');
      gitOperationsMock.branchExists.resolves(false);
      gitOperationsMock.createBranch.rejects(new Error('Git error'));

      const result = await publishService.publishTutorial(manifest);

      expect(result.isErr()).to.be.true;
      if (result.isErr()) {
        expect(result.error).to.equal('GIT_OPERATION_FAILED');
      }
    });

    it('should format commit messages with correct prefixes', async () => {
      const manifest = createTestManifest();
      
      gitOperationsMock.getCurrentBranch.resolves('master');
      gitOperationsMock.branchExists.resolves(false);
      gitOperationsMock.createBranch.resolves();
      gitOperationsMock.checkoutBranch.resolves();
      gitOperationsMock.getCommitInfo.resolves({
        hash: 'abc123def456',
        message: 'Original commit message',
        author: 'Test Author',
        date: new Date(),
      });
      gitOperationsMock.cherryPick.resolves();
      gitOperationsMock.createCommit.resolves('new-commit-hash');

      await publishService.publishTutorial(manifest);

      // Check that cherry pick was called with correct formatted messages
      const cherryPickCalls = gitOperationsMock.cherryPick.getCalls();
      expect(cherryPickCalls[0].args[1]).to.equal('section: Setup Environment');
      expect(cherryPickCalls[1].args[1]).to.equal('template: Build the pallet');
      expect(cherryPickCalls[2].args[1]).to.equal('solution: Build the pallet');
    });
  });

  describe('formatCommitMessage', () => {
    it('should format commit message with type prefix and title', () => {
      const step: ManifestStep = {
        commit: 'abc123',
        type: 'template',
        title: 'Build the pallet',
      };

      const formatted = publishService.formatCommitMessage(step);

      expect(formatted).to.equal('template: Build the pallet');
    });

    it('should handle all step types correctly', () => {
      const stepTypes = [
        { type: 'section' as const, expected: 'section: Test Step' },
        { type: 'template' as const, expected: 'template: Test Step' },
        { type: 'solution' as const, expected: 'solution: Test Step' },
        { type: 'action' as const, expected: 'action: Test Step' },
        { type: 'readme' as const, expected: 'readme: Test Step' },
      ];

      stepTypes.forEach(({ type, expected }) => {
        const step: ManifestStep = {
          commit: 'abc123',
          type,
          title: 'Test Step',
        };

        const formatted = publishService.formatCommitMessage(step);
        expect(formatted).to.equal(expected);
      });
    });
  });

  describe('validateManifestForPublish', () => {
    it('should return Ok for valid manifest', () => {
      const manifest = createTestManifest();

      const result = publishService.validateManifestForPublish(manifest);

      expect(result.isOk()).to.be.true;
    });

    it('should return error when no steps are present', () => {
      // Create manifest with empty steps by using Object.defineProperty to override
      const manifest = new AuthorManifest({
        authoringBranch: 'master',
        publishBranch: 'gitorial',
        steps: [{ commit: 'abc123', type: 'section', title: 'Only step' }],
      });

      // Override the steps property for this test
      Object.defineProperty(manifest, 'steps', {
        value: [],
        writable: true,
        configurable: true,
      });

      const result = publishService.validateManifestForPublish(manifest);

      expect(result.isErr()).to.be.true;
      if (result.isErr()) {
        expect(result.error).to.equal('NO_STEPS_TO_PUBLISH');
      }
    });
  });
});